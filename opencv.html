<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Electricity Meter Reading with OpenCV</title>
<script async src="https://docs.opencv.org/4.x/opencv.js" type="text/javascript"></script>
<style>
  body { font-family: Arial, sans-serif; margin: 20px; }
  img, canvas { width: 100%; max-width: 400px; margin-bottom: 10px; border: 1px solid #ccc; }
  #result { margin-top: 20px; }
</style>
</head>
<body>

<h2>Electricity Meter OCR & Billing (OpenCV)</h2>

<input type="file" accept="image/*" id="uploadImage">
<br><br>
<img id="preview" src="" alt="Uploaded Image Preview">
<canvas id="canvasOutput"></canvas>

<div id="result">
  <p>Previous Reading: <span id="prevReading">0</span></p>
  <p>Current Reading: <span id="currReading">0</span></p>
  <p>Units Consumed: <span id="unitsConsumed">0</span></p>
  <p>Electricity Bill: â‚¹<span id="billAmount">0</span></p>
</div>

<script>
let preview = document.getElementById("preview");
let canvasOutput = document.getElementById("canvasOutput");
let ctx = canvasOutput.getContext("2d");

const prevReadingEl = document.getElementById("prevReading");
const currReadingEl = document.getElementById("currReading");
const unitsConsumedEl = document.getElementById("unitsConsumed");
const billAmountEl = document.getElementById("billAmount");

let prevReading = localStorage.getItem("prevReading") || 0;
prevReadingEl.textContent = prevReading;

// Wait for OpenCV.js to load
function onOpenCvReady() {
    console.log("OpenCV.js is ready.");
}

// Function to process image and detect digits
function processImage(img) {
    canvasOutput.width = img.width;
    canvasOutput.height = img.height;
    ctx.drawImage(img, 0, 0);

    let src = cv.imread(img); // Load image into OpenCV
    let gray = new cv.Mat();
    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0); // convert to grayscale

    // Apply thresholding to get digits clearly
    let thresh = new cv.Mat();
    cv.adaptiveThreshold(gray, thresh, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 11, 2);

    // Optionally: find contours of digits
    let contours = new cv.MatVector();
    let hierarchy = new cv.Mat();
    cv.findContours(thresh, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

    // Extract bounding boxes for contours
    let digitRegions = [];
    for (let i = 0; i < contours.size(); ++i) {
        let cnt = contours.get(i);
        let rect = cv.boundingRect(cnt);
        if (rect.width > 10 && rect.height > 20) { // filter small noise
            digitRegions.push(rect);
            // Draw rectangles for visualization
            cv.rectangle(src, new cv.Point(rect.x, rect.y), new cv.Point(rect.x + rect.width, rect.y + rect.height), [255, 0, 0, 255], 2);
        }
    }

    cv.imshow(canvasOutput, src);

    // Since we do not have trained OCR in OpenCV.js, we fallback to simple method:
    // Crop digit regions, send to Tesseract.js for recognition
    return thresh;
}

// Extract digits using Tesseract.js after OpenCV preprocessing
async function extractDigits(thresh) {
    let dataUrl = canvasOutput.toDataURL("image/png");
    const result = await Tesseract.recognize(dataUrl, 'eng', { logger: m => console.log(m) });
    let text = result.data.text.replace(/\D/g,''); // keep only digits
    return parseInt(text) || 0;
}

// Handle image upload
document.getElementById("uploadImage").addEventListener("change", async (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = async () => {
        preview.src = reader.result;

        // Store as last image in localStorage
        localStorage.setItem("lastMeterImage", reader.result);

        // Load previous reading
        let prevReading = parseInt(localStorage.getItem("prevReading")) || 0;

        // Wait for image to load
        preview.onload = async () => {
            processImage(preview); // Preprocess with OpenCV
            let currReading = await extractDigits(preview);
            currReadingEl.textContent = currReading;

            let units = currReading - prevReading;
            unitsConsumedEl.textContent = units > 0 ? units : 0;

            let bill = units > 0 ? units * 5 : 0;
            billAmountEl.textContent = bill;

            // Update previous reading
            localStorage.setItem("prevReading", currReading);
            prevReadingEl.textContent = prevReading;
        };
    };
    reader.readAsDataURL(file);
});
</script>

</body>
</html>